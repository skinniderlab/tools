from pathlib import Path

import numpy as np
import pandas as pd

from tools.elements import Compound, IsotopeDB
from tools.utils import get_adducts, get_file_delimiter, modify_formula_dict


class Database:
    """
    A database of chemical formulas sampled from a chemical language model
    (CLM), along with key metadata for each:

    - mass: The monoisotopic mass of the formula.
    - formula: The formula itself.
    - charge: The charge of the formula.
    - elemental counts: The count of individual element present in the formula.
    - size: Aggregated frequency with which that formula was sampled.
    - smiles: a representative SMILES for a compound with that formula.

    The database file itself is generated by running setup-formula-database.py
    on a collection of SMILES strings sampled from a CLM.

    Attributes
    ----------
    adducts_db: pd.DataFrame
        DataFrame containing monoisotopic exact masses of molecular ion adducts.
    isotope_db: IsotopeDB
            A list of elements from the isotopes database.
    df: pd.DataFrame
        DataFrame containing formula database with mass, charge, formula, frequency,
        and individual elemental counts.
    """

    def __init__(self, db_filepath: Path, adducts_filepath: Path, isotope_db: IsotopeDB):
        """
        Initializes a database of CLM generated SMILES string.

        Parameters
        ----------
        db_filepath: Path
            Path to sampled formula database containing mass, charge, formula,
            frequency, and individual elemental counts.
        adducts_filepath: Path
            Path to file containing monoisotopic exact masses of molecular ion adducts.
        isotope_db: IsotopeDB
            A list of elements from the isotopes database.

        """
        self.adducts_db = pd.read_csv(adducts_filepath)
        self.isotope_db = isotope_db
        self.df = self._load_database(db_filepath, isotope_db)

    @staticmethod
    def _load_database(db_filepath: Path, isotope_db: IsotopeDB) -> pd.DataFrame:
        """
        Loads the database from the specified filepath and parses element counts based on the
        presence of individual elements in the isotope database. The parsed data is then stored
        as a DataFrame in the class attribute.

        Parameters
        ----------
        db_filepath: Path
            Path to sampled formula database containing mass, charge, formula,
            frequency, and individual elemental counts.


        Returns
        -------
        pd.DataFrame
            DataFrame containing formula database with mass, charge, formula, frequency,
            and individual elemental counts.
        """
        sep = get_file_delimiter(db_filepath)

        db = pd.read_csv(db_filepath, sep=sep)
        elements = [col for col in db.columns if col in isotope_db]

        valid_elements = ("C", "H", "O", "N", "P", "S", "F", "Cl", "Br", "I")

        if len(set(elements) - set(valid_elements)):
            raise ValueError(
                f"Elements in the formula database must not be anything other than: {valid_elements}."
            )

        # Convert every formula_dictionary to compound objects
        db["compound"] = db[elements].apply(lambda x: Compound(x.to_dict(), isotope_db), axis=1)
        return db[["mass", "charge", "size", "smiles", "compound"]]

    def get_adducts(self, adducts_to_consider: list) -> pd.DataFrame:
        """
        Creates charged ions by combining CLM-generated formulas with
        one or more user-specified adducts, emulating the formation of ions observed in mass
        spectrometry experiments. The resulting mass-to-charge (m/z) ratios for all
        adducts are calculated and stored in a new column within the DataFrame.


        Parameters
        ----------
        adducts_to_consider: list
            A list of ion names used to form an adduct.

            Note: The ion mode is currently limited to neutral and positive.
            The ion names are restricted to those found in the ESI_MS_adducts_2020.csv file,
            which contains a list of predefined adducts commonly observed in electrospray
            ionization mass spectrometry (ESI-MS).

        Returns
        -------
        df: pd.DataFrame
            DataFrame containing the formula database with compound, mass, charge, frequency,
            and mass-to-charge ratio of all the generated charged ions.


        References
        ----------
        https://fiehnlab.ucdavis.edu/staff/kind/metabolomics/ms-adduct-calculator/
        """
        df = self.df.copy()

        def _compute_adduct_mass_to_charge(row: pd.Series, adduct: str) -> tuple | None:
            """
            Compute the mass-to-charge ratio (m/z) of adduct ions based on the
            information from the adducts database.
            """
            # Ensure we're not removing element that doesn't exist in a molecule
            if modify_formula_dict(row["compound"].element_count, adduct) is None:
                return None

            _adduct_info = self.adducts_db[self.adducts_db["Ion name"] == adduct]
            if _adduct_info.empty:
                raise ValueError(
                    "Invalid adduct format. Please ensure the format follows 'M[+/-][d][A-Za-z]."
                )

            ion_charge = _adduct_info["Charge"].iloc[0]
            # Mass-to-charge ratio is already incorporated in the 'Mass' column
            # 'Mult' represents 1/charge.
            updated_mass = _adduct_info["Mass"] + _adduct_info["Mult"] * row.mass

            # Neutral molecules are only considered for forming adduct ions with
            # ions that carry either a positive or negative charge.
            # Positively charged molecules, on the other hand, are only
            # considered for forming adducts with neutral atoms.
            if (ion_charge > 0 or ion_charge < 0) and row["charge"] == 0:
                return (updated_mass).iloc[0]
            if ion_charge == 0 and row["charge"] > 0:
                return (updated_mass).iloc[0] / row["charge"]

            return None

        for adduct in adducts_to_consider:
            df[adduct] = self.df.apply(_compute_adduct_mass_to_charge, adduct=adduct, axis=1)

        return df

    def get_decoy_formulas(self, df: pd.DataFrame, modes: list[str]) -> pd.DataFrame:
        """
        Generates decoy formulas by combining charged ions from the provided DataFrame
        with the user-specified elements. Each element from the user-provided list is
        combined with all the charged ions derived from a number of randomly selected
        compounds.

        Parameters
        ----------
        df: pd.DataFrame
            DataFrame containing the formula database with compound, mass, charge, frequency,
            and mass-to-charge ratio of one or more charged ions.

        modes: list
            A list of elements to form a decoy formula. Elements must following the format:
            [+/-][n_elements][element_symbol].

            Note: Currently, only neutral atoms are supported.

        Returns
        -------
        decoy_df: pd.DataFrame
            DataFrame containing the updated formula database with compound, mass, charge,
            frequency, and mass-to-charge ratio of all the generated decoy formulas.
        """

        decoy_df = df.copy(deep=True)
        adducts = get_adducts(list(df.columns))

        def _compute_decoy_mass_to_charge(row: pd.Series, adduct: str) -> float:
            """
            Compute the mass-to-charge ratio (m/z) of decoys incorporated with adduct ions
            based on the information from the adducts database,  and isotope database.
            """
            decoy_mass = self.isotope_db.get_mass_update(row["decoy_mode"])
            _adduct_info = self.adducts_db[self.adducts_db["Ion name"] == adduct]
            return decoy_mass / abs(row["charge"] + _adduct_info["Charge"].values[0])

        random_mode_indices = np.random.randint(0, len(modes), len(df))
        decoy_df["decoy_mode"] = [modes[i] for i in random_mode_indices]
        decoy_df["compound"] = decoy_df.apply(
            lambda x: x.compound.get_updated_compound(adduct=x.decoy_mode), axis=1
        )

        for adduct in adducts:
            decoy_df[adduct] += decoy_df.apply(_compute_decoy_mass_to_charge, adduct=adduct, axis=1)

        # Only return the columns in the original dataframe
        return decoy_df[df.columns]
